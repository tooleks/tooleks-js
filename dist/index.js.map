{"version":3,"file":"index.js","sources":["../src/async/Defer.js","../src/async/timeout.js","../src/utils/types/isArray.js","../src/utils/types/isBoolean.js","../src/utils/types/isUndefined.js","../src/utils/types/isDefined.js","../src/utils/types/isFunction.js","../src/utils/types/isNull.js","../src/utils/types/isNumber.js","../src/utils/types/isNumeric.js","../src/utils/types/isObject.js","../src/utils/types/isString.js","../src/utils/clone.js","../src/utils/optional.js","../src/async/waitUntil.js","../src/DependencyContainer/DependencyContainer.js","../src/EventEmitter/EventEmitter.js","../src/Mapper/Mapper.js"],"sourcesContent":["/**\n * Defer class.\n */\nexport default class Defer {\n    /**\n     * Defer constructor.\n     */\n    constructor() {\n        this._promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        this.promisify = this.promisify.bind(this);\n    }\n\n    /**\n     * Get a promise which will be resolved or rejected with a deferred value.\n     *\n     * @return {Promise<*>}\n     */\n    promisify() {\n        return this._promise;\n    }\n}\n","import Defer from \"./Defer\";\n\nconst DEFAULT_TIME_INTERVAL = 0;\n\n/**\n * Provide promise that will be resolved after time interval.\n *\n * @param {number} [timeInterval=0]\n * @return {Promise<*>}\n */\nexport default function timeout(timeInterval = DEFAULT_TIME_INTERVAL) {\n    const defer = new Defer();\n    setTimeout(() => defer.resolve(), timeInterval);\n    return defer.promisify();\n}\n","/**\n * Determine if value is an array.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isArray(value) {\n    return Array.isArray(value) || value instanceof Array;\n}\n","/**\n * Determine if value is a boolean.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isBoolean(value) {\n    return typeof value === \"boolean\" || value instanceof Boolean;\n}\n","/**\n * Determine if value is an undefined.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isUndefined(value) {\n    return typeof value === \"undefined\";\n}\n","import isUndefined from \"./isUndefined\";\n\n/**\n * Determine if value is not undefined.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isDefined(value) {\n    return !isUndefined(value);\n}\n","/**\n * Determine if value is a function.\n *\n * @param {*} value\n * @param {boolean} value\n * @return {boolean}\n */\nexport default function isFunction(value) {\n    return typeof value === \"function\";\n}\n","/**\n * Determine if value is a null.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isNull(value) {\n    return value === null;\n}\n","/**\n * Determine if value is a number.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isNumber(value) {\n    return typeof value === \"number\" || value instanceof Number;\n}\n","/**\n * Determine if value is a number or numeric string.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isNumeric(value) {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n}\n","/**\n * Determine if value is an object and not null.\n *\n * @param {*} value\n * @param {boolean} value\n * @return {boolean}\n */\nexport default function isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n","/**\n * Determine if value is a string.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n}\n","/* eslint-disable */\n\nimport {isArray, isBoolean, isFunction, isNull, isNumber, isObject, isString, isUndefined} from \"./types\";\n\n/**\n * Clone undefined value.\n *\n * @param {undefined} value\n * @returns {undefined}\n */\nfunction cloneUndefined(value) {\n    return undefined;\n}\n\n/**\n * Clone null value.\n *\n * @param {null} value\n * @returns {null}\n */\nfunction cloneNull(value) {\n    return null;\n}\n\n/**\n * Clone boolean value.\n *\n * @param {boolean} value\n * @returns {boolean}\n */\nfunction cloneBoolean(value) {\n    return Boolean(value);\n}\n\n/**\n * Clone number value.\n *\n * @param {number} value\n * @returns {number}\n */\nfunction cloneNumber(value) {\n    return Number(value);\n}\n\n/**\n * Clone string value.\n *\n * @param {string} value\n * @returns {string}\n */\nfunction cloneString(value) {\n    return String(value);\n}\n\n/**\n * Clone Array value.\n *\n * @param {Array} value\n * @returns {Array}\n */\nfunction cloneArray(value) {\n    return value.map((item) => clone(item));\n}\n\n/**\n * Clone Map value.\n *\n * @param {Map} value\n * @returns {Map}\n */\nfunction cloneMap(value) {\n    return new Map(clone(Array.from(value)));\n}\n\n/**\n * Clone Date value.\n *\n * @param {Date} value\n * @returns {Date}\n */\nfunction cloneDate(value) {\n    return new Date(value.valueOf());\n}\n\n/**\n * Clone RegExp value.\n *\n * @param {RegExp} value\n * @returns {RegExp}\n */\nfunction cloneRegExp(value) {\n    let pattern = value.source;\n    let flags = \"\";\n    if (value.global) {\n        flags += \"g\";\n    }\n    if (value.ignoreCase) {\n        flags += \"i\";\n    }\n    if (value.multiline) {\n        flags += \"m\";\n    }\n    return new RegExp(pattern, flags);\n}\n\n/**\n * Clone Object value.\n *\n * @param {Object} value\n * @returns {Object}\n * @throws Error\n */\nfunction cloneObject(value) {\n    // Overidden clone method.\n    if (value.clone && isFunction(value.clone)) {\n        return value.clone();\n    }\n    // DOM node object.\n    else if (value.nodeType && isFunction(value.cloneNode)) {\n        return value.cloneNode(true);\n    }\n    // Object literal.\n    else if (isUndefined(value.prototype)) {\n        return Object.keys(value).reduce((clonedObject, key) => {\n            const property = value[key];\n            clonedObject[key] = clone(property);\n            return clonedObject;\n        }, {});\n    }\n\n    throw new Error(\"Unable to clone the object. Implement the 'clone' method manually.\");\n}\n\n/**\n * Clone Function value.\n *\n * @param {Function} value\n * @returns {Function}\n */\nfunction cloneFunction(value) {\n    // Root function.\n    const clonedFunction = function() {\n        return value.apply(value, arguments);\n    };\n\n    // Function keys.\n    Object.keys(value).forEach((key) => {\n        const property = value[key];\n        clonedFunction[key] = clone(property);\n    });\n\n    return clonedFunction;\n}\n\n/**\n * Clone value.\n *\n * @param {*} value\n * @returns {*}\n * @throws Error\n */\nexport default function clone(value) {\n    if (isUndefined(value)) {\n        return cloneUndefined(value);\n    } else if (isNull(value)) {\n        return cloneNull(value);\n    } else if (isBoolean(value)) {\n        return cloneBoolean(value);\n    } else if (isNumber(value)) {\n        return cloneNumber(value);\n    } else if (isString(value)) {\n        return cloneString(value);\n    } else if (isArray(value)) {\n        return cloneArray(value);\n    } else if (value instanceof Map) {\n        return cloneMap(value);\n    } else if (value instanceof Date) {\n        return cloneDate(value);\n    } else if (value instanceof RegExp) {\n        return cloneRegExp(value);\n    } else if (isObject(value)) {\n        return cloneObject(value);\n    } else if (isFunction(value)) {\n        return cloneFunction(value);\n    }\n\n    throw new Error(`Unable to clone the ${typeof value}.`);\n}\n","import {isDefined} from \"./types\";\n\n/**\n * Retrieve the result of callback call. If an error occurred or result is undefined return a default value instead.\n *\n * @param {Function} callback\n * @param {*} defaultValue\n * @return {*}\n */\nexport default function optional(callback, defaultValue = undefined) {\n    try {\n        const value = callback();\n        if (isDefined(value)) {\n            return value;\n        }\n        return defaultValue;\n    } catch (error) {\n        return defaultValue;\n    }\n}\n","import Defer from \"./Defer\";\nimport {isFunction} from \"../utils\";\n\nconst DEFAULT_TIME_INTERVAL = 0;\n\n/**\n * Assert \"callback\" parameter.\n *\n * @param {*} callback\n * @return {void}\n * @throws TypeError\n */\nfunction assertCallbackParameter(callback) {\n    if (!isFunction(callback)) {\n        throw new TypeError('The \"callback\" parameter should be a function.');\n    }\n}\n\n/**\n * Provide promise that will be resolved when callback will return truthy value.\n *\n * @param {function} callback\n * @param {number} {timeInterval=0}\n * @return {Promise<*>}\n */\nexport default function waitUntil(callback, timeInterval = DEFAULT_TIME_INTERVAL) {\n    assertCallbackParameter(callback);\n    const defer = new Defer();\n    const intervalId = setInterval(() => {\n        try {\n            const result = callback();\n            if (result) {\n                clearInterval(intervalId);\n                defer.resolve(result);\n            }\n        } catch (error) {\n            defer.reject(error);\n        }\n    }, timeInterval);\n    return defer.promisify();\n}\n","import {isArray, isBoolean, isDefined, isFunction, isString, isUndefined} from \"../utils\";\n\n/**\n * Assert \"identifier\" parameter.\n *\n * @param {*} identifier\n * @return {void}\n * @throws TypeError\n */\nfunction assertIdentifierParameter(identifier) {\n    if (!isString(identifier)) {\n        throw new TypeError('The \"identifier\" parameter should be a string.');\n    }\n}\n\n/**\n * Assert \"type\" parameter.\n *\n * @param {*} type\n * @return {void}\n * @throws TypeError\n */\nfunction assertTypeParameter(type) {\n    if (!isFunction(type)) {\n        throw new TypeError('The \"type\" parameter should be a function.');\n    }\n}\n\n/**\n * Assert \"dependencies\" parameter.\n *\n * @param {*} dependencies\n * @return {void}\n * @throws TypeError\n */\nfunction assertDependenciesParameter(dependencies) {\n    if (!isArray(dependencies)) {\n        throw new TypeError('The \"dependencies\" parameter should be an array.');\n    }\n    dependencies.forEach((dependency) => {\n        if (!isString(dependency) && !isFunction(dependency)) {\n            throw new TypeError('The \"dependencies\" parameter should be an array of strings or functions.');\n        }\n    });\n}\n\n/**\n * Assert \"singleton\" parameter.\n *\n * @param {*} singleton\n * @return {void}\n * @throws TypeError\n */\nfunction assertSingletonParameter(singleton) {\n    if (!isBoolean(singleton)) {\n        throw new TypeError('The \"singleton\" parameter should be a boolean.');\n    }\n}\n\n/**\n * Assert \"factory\" parameter.\n *\n * @param {*} factory\n * @return {void}\n * @throws TypeError\n */\nfunction assertFactoryParameter(factory) {\n    if (!isBoolean(factory)) {\n        throw new TypeError('The \"factory\" parameter should be a boolean.');\n    }\n}\n\n/**\n * Assert \"instance\" parameter.\n *\n * @param {*} instance\n * @return {void}\n * @throws TypeError\n */\nfunction assertInstanceParameter(instance) {\n    if (isUndefined(instance)) {\n        throw new TypeError('The \"instance\" parameter should not be an undefined.');\n    }\n}\n\n/**\n * DependencyContainer class.\n */\nexport default class DependencyContainer {\n    /**\n     * DependencyContainer constructor.\n     */\n    constructor() {\n        this._bindings = {};\n        this._createInstance = this._createInstance.bind(this);\n        this._resolveDependencies = this._resolveDependencies.bind(this);\n        this.registerBinding = this.registerBinding.bind(this);\n        this.registerInstance = this.registerInstance.bind(this);\n        this.removeBinding = this.removeBinding.bind(this);\n        this.has = this.has.bind(this);\n        this.get = this.get.bind(this);\n    }\n\n    /**\n     * Create an instance for a binding.\n     *\n     * @param {Object} binding\n     * @return {*}\n     * @private\n     */\n    _createInstance(binding) {\n        const dependencies = this._resolveDependencies(binding.dependencies);\n        let instance = null;\n        if (binding.factory) {\n            instance = binding.type(...dependencies);\n        } else {\n            instance = new binding.type(...dependencies);\n        }\n        return instance;\n    }\n\n    /**\n     * Resolve all of dependencies for a binding.\n     *\n     * @param {Array<string|Function>} dependencies\n     * @private\n     */\n    _resolveDependencies(dependencies) {\n        return dependencies.map((dependency) => {\n            if (isString(dependency)) {\n                return this.get(dependency);\n            } else if (isFunction(dependency)) {\n                return dependency();\n            }\n            throw new TypeError(\"Invalid dependency type.\");\n        });\n    }\n\n    /**\n     * Register a new binding in the container.\n     *\n     * @param {string} identifier\n     * @param {Function|*} type\n     * @param {Object} options\n     * @param {Array<string|Function>} options.dependencies\n     * @param {boolean} options.singleton\n     * @param {boolean} options.factory\n     * @return {DependencyContainer}\n     */\n    registerBinding(identifier, type, {dependencies = [], singleton = false, factory = false} = {}) {\n        assertIdentifierParameter(identifier);\n        assertTypeParameter(type);\n        assertDependenciesParameter(dependencies);\n        assertSingletonParameter(singleton);\n        assertFactoryParameter(factory);\n\n        // Check dependencies list length.\n        if (type.length !== dependencies.length) {\n            throw new Error(`Invalid number of dependencies were specified for \"${identifier}\".`);\n        }\n\n        // Check for circular dependencies.\n        dependencies.forEach((dependency) => {\n            if (dependency === identifier) {\n                throw new Error(`Circular dependency detected. ${identifier} depends on itself.`);\n            }\n\n            if (isDefined(this._bindings[dependency])) {\n                this._bindings[dependency].dependencies.forEach((innerDependency) => {\n                    if (innerDependency === identifier) {\n                        throw new Error(\n                            \"Circular dependency detected. \" +\n                                `\"${identifier}\" depends on \"${dependency}\" and vise versa.`,\n                        );\n                    }\n                });\n            }\n        });\n\n        this._bindings[identifier] = {type, dependencies, singleton, factory};\n\n        return this;\n    }\n\n    /**\n     * Register an instance in the container.\n     *\n     * @param {string} identifier\n     * @param {*} instance\n     * @return {DependencyContainer}\n     */\n    registerInstance(identifier, instance) {\n        assertIdentifierParameter(identifier);\n        assertInstanceParameter(instance);\n        this._bindings[identifier] = {instance, dependencies: [], singleton: true, factory: false};\n        return this;\n    }\n\n    /**\n     * Remove the binding from the container.\n     *\n     * @param {string} identifier\n     * @return {DependencyContainer}\n     */\n    removeBinding(identifier) {\n        assertIdentifierParameter(identifier);\n        if (this.has(identifier)) {\n            delete this._bindings[identifier];\n        }\n        return this;\n    }\n\n    /**\n     * Return true if the container can return the binding for the given identifier.\n     * Return false otherwise.\n     *\n     * @param {string} identifier\n     * @return {boolean}\n     */\n    has(identifier) {\n        assertIdentifierParameter(identifier);\n        return Object.prototype.hasOwnProperty.call(this._bindings, identifier);\n    }\n\n    /**\n     * Find the binding of the container by its identifier and return it.\n     *\n     * @param {string} identifier\n     * @return {*}\n     */\n    get(identifier) {\n        assertIdentifierParameter(identifier);\n        if (!this.has(identifier)) {\n            throw new Error(`The \"${identifier}\" binding not found.`);\n        }\n        const binding = this._bindings[identifier];\n        if (isDefined(binding.instance)) {\n            return binding.instance;\n        }\n        const instance = this._createInstance(binding);\n        if (binding.singleton) {\n            binding.instance = instance;\n        }\n        return instance;\n    }\n}\n","import {isFunction, isString, isUndefined} from \"../utils\";\nimport {Defer} from \"../async\";\n\n/**\n * Assert \"eventName\" parameter.\n *\n * @param {*} eventName\n * @return {void}\n * @throws TypeError\n */\nfunction assertEventNameParameter(eventName) {\n    if (!isString(eventName)) {\n        throw new TypeError('The \"eventName\" parameter should be a string.');\n    }\n}\n\n/**\n * Assert \"listener\" parameter.\n *\n * @param {*} listener\n * @return {void}\n * @throws TypeError\n */\nfunction assertListenerParameter(listener) {\n    if (!isFunction(listener)) {\n        throw new TypeError('The \"listener\" parameter should be a function.');\n    }\n}\n\n/**\n * EventEmitter class.\n */\nexport default class EventEmitter {\n    /**\n     * EventEmitter constructor.\n     */\n    constructor() {\n        this._events = {};\n        this._callEventListeners = this._callEventListeners.bind(this);\n        this.emit = this.emit.bind(this);\n        this.emitAsync = this.emitAsync.bind(this);\n        this.on = this.on.bind(this);\n    }\n\n    /**\n     * Synchronously call each of the listeners registered for the event named eventName.\n     *\n     * @param {string} eventName\n     * @param {*} payload\n     * @return {Array<*>}\n     * @private\n     */\n    _callEventListeners(eventName, payload) {\n        assertEventNameParameter(eventName);\n        const listeners = this._events[eventName];\n        if (isUndefined(listeners)) {\n            return [];\n        }\n        return listeners.map((listener) => listener(payload));\n    }\n\n    /**\n     * Synchronously call each of the listeners registered for the event named eventName.\n     *\n     * @param {string} eventName\n     * @param {*} payload\n     * @return {void}\n     */\n    emit(eventName, payload) {\n        this._callEventListeners(eventName, payload);\n    }\n\n    /**\n     * Asynchronously call each of the listeners registered for the event named eventName.\n     *\n     * @param {string} eventName\n     * @param {*} payload\n     * @return {Promise<Array<*>>} - A promise that will be resolved when each of the listeners will be resolved.\n     */\n    emitAsync(eventName, payload) {\n        const defer = new Defer();\n        setImmediate(() => {\n            Promise.all(this._callEventListeners(eventName, payload))\n                .then(defer.resolve)\n                .catch(defer.reject);\n        });\n        return defer.promisify();\n    }\n\n    /**\n     * Add the listener function to the end of the listeners array for the event named eventName.\n     *\n     * @param {string} eventName\n     * @param {Function} listener\n     * @return {Function} - A function to remove the listener function from the listeners array for the event named eventName.\n     */\n    on(eventName, listener) {\n        assertEventNameParameter(eventName);\n        assertListenerParameter(listener);\n        if (isUndefined(this._events[eventName])) {\n            this._events[eventName] = [];\n        }\n        this._events[eventName].push(listener);\n        return () => {\n            this._events[eventName] = this._events[eventName].filter((eventListener) => eventListener !== listener);\n            // Remove event listeners property to optimize memory usage.\n            if (!this._events[eventName].length) {\n                delete this._events[eventName];\n            }\n        };\n    }\n}\n","import {isFunction, isString, isUndefined} from \"../utils\";\n\n/**\n * Assert \"from\" parameter.\n *\n * @param {*} from\n * @return {void}\n * @throws TypeError\n */\nfunction assertFromParameter(from) {\n    if (!isString(from)) {\n        throw new TypeError('The \"from\" parameter should be a string.');\n    }\n}\n\n/**\n * Assert \"to\" parameter.\n *\n * @param {*} to\n * @return {void}\n * @throws TypeError\n */\nfunction assertToParameter(to) {\n    if (!isString(to)) {\n        throw new TypeError('The \"to\" parameter should be a string.');\n    }\n}\n\n/**\n * Assert \"resolver\" parameter.\n *\n * @param {*} resolver\n * @return {void}\n * @throws TypeError\n */\nfunction assertResolverParameter(resolver) {\n    if (!isFunction(resolver)) {\n        throw new TypeError('The \"resolver\" parameter should be a function.');\n    }\n}\n\n/**\n * Mapper class.\n */\nexport default class Mapper {\n    /**\n     * Mapper constructor.\n     */\n    constructor() {\n        this._resolvers = {};\n        this._assertResolver = this._assertResolver.bind(this);\n        this.registerResolver = this.registerResolver.bind(this);\n        this.hasResolver = this.hasResolver.bind(this);\n        this.removeResolver = this.removeResolver.bind(this);\n        this.map = this.map.bind(this);\n    }\n\n    /**\n     * Assert that the resolver function for from-to mapping exists.\n     *\n     * @param {string} from\n     * @param {string} to\n     * @return {void}\n     * @private\n     */\n    _assertResolver(from, to) {\n        if (isUndefined(this._resolvers[from])) {\n            throw new Error(`Resolver for \"${from}\" not found.`);\n        }\n        if (isUndefined(this._resolvers[from][to])) {\n            throw new Error(`Resolver for \"${to}\" not found.`);\n        }\n    }\n\n    /**\n     * Register the resolver function for from-to mapping.\n     *\n     * @param {string} from\n     * @param {string} to\n     * @param {Function} resolver\n     * @return {Mapper}\n     */\n    registerResolver(from, to, resolver) {\n        assertFromParameter(from);\n        assertToParameter(to);\n        assertResolverParameter(resolver);\n        if (isUndefined(this._resolvers[from])) {\n            this._resolvers[from] = {};\n        }\n        this._resolvers[from][to] = resolver;\n        return this;\n    }\n\n    /**\n     * Determine that the resolver function for from-to mapping is registered.\n     *\n     * @param {string} from\n     * @param {string} to\n     * @return {boolean}\n     */\n    hasResolver(from, to) {\n        assertFromParameter(from);\n        assertToParameter(to);\n        try {\n            this._assertResolver(from, to);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Remove the resolver function for from-to mapping.\n     *\n     * @param {string} from\n     * @param {string} to\n     * @return {Mapper}\n     */\n    removeResolver(from, to) {\n        assertFromParameter(from);\n        assertToParameter(to);\n        if (this.hasResolver(from, to)) {\n            delete this._resolvers[from][to];\n        }\n        return this;\n    }\n\n    /**\n     * Map value by using from-to resolver function.\n     *\n     * @param {*} value\n     * @param {string} from\n     * @param {string} to\n     * @return {*}\n     */\n    map(value, from, to) {\n        assertFromParameter(from);\n        assertToParameter(to);\n        this._assertResolver(from, to);\n        const resolver = this._resolvers[from][to];\n        return resolver(value);\n    }\n}\n"],"names":["Defer","_promise","Promise","resolve","reject","promisify","bind","DEFAULT_TIME_INTERVAL","timeout","timeInterval","defer","setTimeout","isArray","value","Array","isBoolean","Boolean","isUndefined","isDefined","isFunction","isNull","isNumber","Number","isNumeric","isNaN","parseFloat","isFinite","isObject","isString","String","cloneUndefined","undefined","cloneNull","cloneBoolean","cloneNumber","cloneString","cloneArray","map","item","clone","cloneMap","Map","from","cloneDate","Date","valueOf","cloneRegExp","pattern","source","flags","global","ignoreCase","multiline","RegExp","cloneObject","nodeType","cloneNode","prototype","Object","keys","reduce","clonedObject","key","property","Error","cloneFunction","clonedFunction","apply","arguments","forEach","optional","callback","defaultValue","error","assertCallbackParameter","TypeError","waitUntil","intervalId","setInterval","result","clearInterval","assertIdentifierParameter","identifier","assertTypeParameter","type","assertDependenciesParameter","dependencies","dependency","assertSingletonParameter","singleton","assertFactoryParameter","factory","assertInstanceParameter","instance","DependencyContainer","_bindings","_createInstance","_resolveDependencies","registerBinding","registerInstance","removeBinding","has","get","binding","length","innerDependency","hasOwnProperty","call","assertEventNameParameter","eventName","assertListenerParameter","listener","EventEmitter","_events","_callEventListeners","emit","emitAsync","on","payload","listeners","setImmediate","all","then","catch","push","filter","eventListener","assertFromParameter","assertToParameter","to","assertResolverParameter","resolver","Mapper","_resolvers","_assertResolver","registerResolver","hasResolver","removeResolver"],"mappings":"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"}