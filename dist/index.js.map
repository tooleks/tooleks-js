{"version":3,"file":"index.js","sources":["../src/async/Defer.js","../src/async/timeout.js","../src/utils/types/isArray.js","../src/utils/types/isBoolean.js","../src/utils/types/isUndefined.js","../src/utils/types/isDefined.js","../src/utils/types/isFunction.js","../src/utils/types/isNull.js","../src/utils/types/isNumber.js","../src/utils/types/isNumeric.js","../src/utils/types/isObject.js","../src/utils/types/isString.js","../src/utils/clone.js","../src/utils/optional.js","../src/async/waitUntil.js","../src/DependencyContainer/DependencyContainer.js","../src/EventEmitter/EventEmitter.js","../src/Mapper/Mapper.js"],"sourcesContent":["/**\n * Defer class.\n */\nexport default class Defer {\n    /**\n     * Defer constructor.\n     */\n    constructor() {\n        this._promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        this.promisify = this.promisify.bind(this);\n    }\n\n    /**\n     * Get a promise which will be resolved or rejected with a deferred value.\n     *\n     * @return {Promise<*>}\n     */\n    promisify() {\n        return this._promise;\n    }\n}\n","import Defer from \"./Defer\";\n\nconst DEFAULT_TIME_INTERVAL = 0;\n\n/**\n * Provide promise that will be resolved after time interval.\n *\n * @param {number} [timeInterval=0]\n * @return {Promise<*>}\n */\nexport default function timeout(timeInterval = DEFAULT_TIME_INTERVAL) {\n    const defer = new Defer();\n    setTimeout(() => defer.resolve(), timeInterval);\n    return defer.promisify();\n}\n","/**\n * Determine if value is an array.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isArray(value) {\n    return Array.isArray(value) || value instanceof Array;\n}\n","/**\n * Determine if value is a boolean.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isBoolean(value) {\n    return typeof value === \"boolean\" || value instanceof Boolean;\n}\n","/**\n * Determine if value is an undefined.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isUndefined(value) {\n    return typeof value === \"undefined\";\n}\n","import isUndefined from \"./isUndefined\";\n\n/**\n * Determine if value is not undefined.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isDefined(value) {\n    return !isUndefined(value);\n}\n","/**\n * Determine if value is a function.\n *\n * @param {*} value\n * @param {boolean} value\n * @return {boolean}\n */\nexport default function isFunction(value) {\n    return typeof value === \"function\";\n}\n","/**\n * Determine if value is a null.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isNull(value) {\n    return value === null;\n}\n","/**\n * Determine if value is a number.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isNumber(value) {\n    return typeof value === \"number\" || value instanceof Number;\n}\n","/**\n * Determine if value is a number or numeric string.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isNumeric(value) {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n}\n","/**\n * Determine if value is an object and not null.\n *\n * @param {*} value\n * @param {boolean} value\n * @return {boolean}\n */\nexport default function isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n","/**\n * Determine if value is a string.\n *\n * @param {*} value\n * @return {boolean}\n */\nexport default function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n}\n","/* eslint-disable */\n\nimport {isArray, isBoolean, isFunction, isNull, isNumber, isObject, isString, isUndefined} from \"./types\";\n\n/**\n * Clone undefined value.\n *\n * @param {undefined} value\n * @returns {undefined}\n */\nfunction cloneUndefined(value) {\n    return undefined;\n}\n\n/**\n * Clone null value.\n *\n * @param {null} value\n * @returns {null}\n */\nfunction cloneNull(value) {\n    return null;\n}\n\n/**\n * Clone boolean value.\n *\n * @param {boolean} value\n * @returns {boolean}\n */\nfunction cloneBoolean(value) {\n    return Boolean(value);\n}\n\n/**\n * Clone number value.\n *\n * @param {number} value\n * @returns {number}\n */\nfunction cloneNumber(value) {\n    return Number(value);\n}\n\n/**\n * Clone string value.\n *\n * @param {string} value\n * @returns {string}\n */\nfunction cloneString(value) {\n    return String(value);\n}\n\n/**\n * Clone Array value.\n *\n * @param {Array} value\n * @returns {Array}\n */\nfunction cloneArray(value) {\n    return value.map((item) => clone(item));\n}\n\n/**\n * Clone Map value.\n *\n * @param {Map} value\n * @returns {Map}\n */\nfunction cloneMap(value) {\n    return new Map(clone(Array.from(value)));\n}\n\n/**\n * Clone Date value.\n *\n * @param {Date} value\n * @returns {Date}\n */\nfunction cloneDate(value) {\n    return new Date(value.valueOf());\n}\n\n/**\n * Clone RegExp value.\n *\n * @param {RegExp} value\n * @returns {RegExp}\n */\nfunction cloneRegExp(value) {\n    let pattern = value.source;\n    let flags = \"\";\n    if (value.global) {\n        flags += \"g\";\n    }\n    if (value.ignoreCase) {\n        flags += \"i\";\n    }\n    if (value.multiline) {\n        flags += \"m\";\n    }\n    return new RegExp(pattern, flags);\n}\n\n/**\n * Clone Object value.\n *\n * @param {object} value\n * @returns {object}\n * @throws Error\n */\nfunction cloneObject(value) {\n    // Overidden clone method.\n    if (value.clone && isFunction(value.clone)) {\n        return value.clone();\n    }\n    // DOM node object.\n    else if (value.nodeType && isFunction(value.cloneNode)) {\n        return value.cloneNode(true);\n    }\n    // Object literal.\n    else if (isUndefined(value.prototype)) {\n        return Object.keys(value).reduce((clonedObject, key) => {\n            const property = value[key];\n            clonedObject[key] = clone(property);\n            return clonedObject;\n        }, {});\n    }\n\n    throw new Error(\"Unable to clone the object. Implement the 'clone' method manually.\");\n}\n\n/**\n * Clone Function value.\n *\n * @param {function} value\n * @returns {function}\n */\nfunction cloneFunction(value) {\n    // Root function.\n    const clonedFunction = function() {\n        return value.apply(value, arguments);\n    };\n\n    // Function keys.\n    Object.keys(value).forEach((key) => {\n        const property = value[key];\n        clonedFunction[key] = clone(property);\n    });\n\n    return clonedFunction;\n}\n\n/**\n * Clone value.\n *\n * @param {*} value\n * @returns {*}\n * @throws Error\n */\nexport default function clone(value) {\n    if (isUndefined(value)) {\n        return cloneUndefined(value);\n    } else if (isNull(value)) {\n        return cloneNull(value);\n    } else if (isBoolean(value)) {\n        return cloneBoolean(value);\n    } else if (isNumber(value)) {\n        return cloneNumber(value);\n    } else if (isString(value)) {\n        return cloneString(value);\n    } else if (isArray(value)) {\n        return cloneArray(value);\n    } else if (value instanceof Map) {\n        return cloneMap(value);\n    } else if (value instanceof Date) {\n        return cloneDate(value);\n    } else if (value instanceof RegExp) {\n        return cloneRegExp(value);\n    } else if (isObject(value)) {\n        return cloneObject(value);\n    } else if (isFunction(value)) {\n        return cloneFunction(value);\n    }\n\n    throw new Error(`Unable to clone the ${typeof value}.`);\n}\n","import {isDefined} from \"./types\";\n\n/**\n * Retrieve the result of callback call. If an error occurred or result is undefined return a default value instead.\n *\n * @param {function} callback\n * @param {*} defaultValue\n * @return {*}\n */\nexport default function optional(callback, defaultValue = undefined) {\n    try {\n        const value = callback();\n        if (isDefined(value)) {\n            return value;\n        }\n        return defaultValue;\n    } catch (error) {\n        return defaultValue;\n    }\n}\n","import Defer from \"./Defer\";\nimport {isFunction} from \"../utils\";\n\nconst DEFAULT_TIME_INTERVAL = 0;\n\n/**\n * Assert \"callback\" parameter.\n *\n * @param {*} callback\n * @return {void}\n * @throws TypeError\n */\nfunction assertCallbackParameter(callback) {\n    if (!isFunction(callback)) {\n        throw new TypeError('The \"callback\" parameter should be a function.');\n    }\n}\n\n/**\n * Provide promise that will be resolved when callback will return truthy value.\n *\n * @param {function} callback\n * @param {number} {timeInterval=0}\n * @return {Promise<*>}\n */\nexport default function waitUntil(callback, timeInterval = DEFAULT_TIME_INTERVAL) {\n    assertCallbackParameter(callback);\n    const defer = new Defer();\n    const intervalId = setInterval(() => {\n        try {\n            const result = callback();\n            if (result) {\n                clearInterval(intervalId);\n                defer.resolve(result);\n            }\n        } catch (error) {\n            defer.reject(error);\n        }\n    }, timeInterval);\n    return defer.promisify();\n}\n","import {isArray, isBoolean, isDefined, isFunction, isString, isUndefined} from \"../utils\";\n\n/**\n * Assert \"identifier\" parameter.\n *\n * @param {*} identifier\n * @return {void}\n * @throws TypeError\n */\nfunction assertIdentifierParameter(identifier) {\n    if (!isString(identifier)) {\n        throw new TypeError('The \"identifier\" parameter should be a string.');\n    }\n}\n\n/**\n * Assert \"type\" parameter.\n *\n * @param {*} type\n * @return {void}\n * @throws TypeError\n */\nfunction assertTypeParameter(type) {\n    if (!isFunction(type)) {\n        throw new TypeError('The \"type\" parameter should be a function.');\n    }\n}\n\n/**\n * Assert \"dependencies\" parameter.\n *\n * @param {*} dependencies\n * @return {void}\n * @throws TypeError\n */\nfunction assertDependenciesParameter(dependencies) {\n    if (!isArray(dependencies)) {\n        throw new TypeError('The \"dependencies\" parameter should be an array.');\n    }\n    dependencies.forEach((dependency) => {\n        if (!isString(dependency) && !isFunction(dependency)) {\n            throw new TypeError('The \"dependencies\" parameter should be an array of strings or functions.');\n        }\n    });\n}\n\n/**\n * Assert \"singleton\" parameter.\n *\n * @param {*} singleton\n * @return {void}\n * @throws TypeError\n */\nfunction assertSingletonParameter(singleton) {\n    if (!isBoolean(singleton)) {\n        throw new TypeError('The \"singleton\" parameter should be a boolean.');\n    }\n}\n\n/**\n * Assert \"factory\" parameter.\n *\n * @param {*} factory\n * @return {void}\n * @throws TypeError\n */\nfunction assertFactoryParameter(factory) {\n    if (!isBoolean(factory)) {\n        throw new TypeError('The \"factory\" parameter should be a boolean.');\n    }\n}\n\n/**\n * Assert \"instance\" parameter.\n *\n * @param {*} instance\n * @return {void}\n * @throws TypeError\n */\nfunction assertInstanceParameter(instance) {\n    if (isUndefined(instance)) {\n        throw new TypeError('The \"instance\" parameter should not be an undefined.');\n    }\n}\n\n/**\n * DependencyContainer class.\n */\nexport default class DependencyContainer {\n    /**\n     * DependencyContainer constructor.\n     */\n    constructor() {\n        this._bindings = {};\n        this._createInstance = this._createInstance.bind(this);\n        this._resolveDependencies = this._resolveDependencies.bind(this);\n        this.registerBinding = this.registerBinding.bind(this);\n        this.registerInstance = this.registerInstance.bind(this);\n        this.removeBinding = this.removeBinding.bind(this);\n        this.has = this.has.bind(this);\n        this.get = this.get.bind(this);\n    }\n\n    /**\n     * Create an instance for a binding.\n     *\n     * @param {object} binding\n     * @return {*}\n     * @private\n     */\n    _createInstance(binding) {\n        const dependencies = this._resolveDependencies(binding.dependencies);\n        let instance = null;\n        if (binding.factory) {\n            instance = binding.type(...dependencies);\n        } else {\n            instance = new binding.type(...dependencies);\n        }\n        return instance;\n    }\n\n    /**\n     * Resolve all of dependencies for a binding.\n     *\n     * @param {Array<string|Function>} dependencies\n     * @private\n     */\n    _resolveDependencies(dependencies) {\n        return dependencies.map((dependency) => {\n            if (isString(dependency)) {\n                return this.get(dependency);\n            } else if (isFunction(dependency)) {\n                return dependency();\n            }\n            throw new TypeError(\"Invalid dependency type.\");\n        });\n    }\n\n    /**\n     * Register a new binding in the container.\n     *\n     * @param {string} identifier\n     * @param {function|*} type\n     * @param {object} options\n     * @param {Array<string|Function>} options.dependencies\n     * @param {boolean} options.singleton\n     * @param {boolean} options.factory\n     * @return {DependencyContainer}\n     */\n    registerBinding(identifier, type, {dependencies = [], singleton = false, factory = false} = {}) {\n        assertIdentifierParameter(identifier);\n        assertTypeParameter(type);\n        assertDependenciesParameter(dependencies);\n        assertSingletonParameter(singleton);\n        assertFactoryParameter(factory);\n\n        // Check dependencies list length.\n        if (type.length !== dependencies.length) {\n            throw new Error(`Invalid number of dependencies were specified for \"${identifier}\".`);\n        }\n\n        // Check for circular dependencies.\n        dependencies.forEach((dependency) => {\n            if (dependency === identifier) {\n                throw new Error(`Circular dependency detected. ${identifier} depends on itself.`);\n            }\n\n            if (isDefined(this._bindings[dependency])) {\n                this._bindings[dependency].dependencies.forEach((innerDependency) => {\n                    if (innerDependency === identifier) {\n                        throw new Error(\n                            \"Circular dependency detected. \" +\n                                `\"${identifier}\" depends on \"${dependency}\" and vise versa.`,\n                        );\n                    }\n                });\n            }\n        });\n\n        this._bindings[identifier] = {type, dependencies, singleton, factory};\n\n        return this;\n    }\n\n    /**\n     * Register an instance in the container.\n     *\n     * @param {string} identifier\n     * @param {*} instance\n     * @return {DependencyContainer}\n     */\n    registerInstance(identifier, instance) {\n        assertIdentifierParameter(identifier);\n        assertInstanceParameter(instance);\n        this._bindings[identifier] = {instance, dependencies: [], singleton: true, factory: false};\n        return this;\n    }\n\n    /**\n     * Remove the binding from the container.\n     *\n     * @param {string} identifier\n     * @return {DependencyContainer}\n     */\n    removeBinding(identifier) {\n        assertIdentifierParameter(identifier);\n        if (this.has(identifier)) {\n            delete this._bindings[identifier];\n        }\n        return this;\n    }\n\n    /**\n     * Return true if the container can return the binding for the given identifier.\n     * Return false otherwise.\n     *\n     * @param {string} identifier\n     * @return {boolean}\n     */\n    has(identifier) {\n        assertIdentifierParameter(identifier);\n        return Object.prototype.hasOwnProperty.call(this._bindings, identifier);\n    }\n\n    /**\n     * Find the binding of the container by its identifier and return it.\n     *\n     * @param {string} identifier\n     * @return {*}\n     */\n    get(identifier) {\n        assertIdentifierParameter(identifier);\n        if (!this.has(identifier)) {\n            throw new Error(`The \"${identifier}\" binding not found.`);\n        }\n        const binding = this._bindings[identifier];\n        if (isDefined(binding.instance)) {\n            return binding.instance;\n        }\n        const instance = this._createInstance(binding);\n        if (binding.singleton) {\n            binding.instance = instance;\n        }\n        return instance;\n    }\n}\n","import {isFunction, isString, isUndefined} from \"../utils\";\nimport {Defer} from \"../async\";\n\n/**\n * Assert \"eventName\" parameter.\n *\n * @param {*} eventName\n * @return {void}\n * @throws TypeError\n */\nfunction assertEventNameParameter(eventName) {\n    if (!isString(eventName)) {\n        throw new TypeError('The \"eventName\" parameter should be a string.');\n    }\n}\n\n/**\n * Assert \"listener\" parameter.\n *\n * @param {*} listener\n * @return {void}\n * @throws TypeError\n */\nfunction assertListenerParameter(listener) {\n    if (!isFunction(listener)) {\n        throw new TypeError('The \"listener\" parameter should be a function.');\n    }\n}\n\n/**\n * EventEmitter class.\n */\nexport default class EventEmitter {\n    /**\n     * EventEmitter constructor.\n     */\n    constructor() {\n        this._events = {};\n        this._callEventListeners = this._callEventListeners.bind(this);\n        this.emit = this.emit.bind(this);\n        this.emitAsync = this.emitAsync.bind(this);\n        this.on = this.on.bind(this);\n    }\n\n    /**\n     * Synchronously call each of the listeners registered for the event named eventName.\n     *\n     * @param {string} eventName\n     * @param {*} payload\n     * @return {Array<*>}\n     * @private\n     */\n    _callEventListeners(eventName, payload) {\n        assertEventNameParameter(eventName);\n        const listeners = this._events[eventName];\n        if (isUndefined(listeners)) {\n            return [];\n        }\n        return listeners.map((listener) => listener(payload));\n    }\n\n    /**\n     * Synchronously call each of the listeners registered for the event named eventName.\n     *\n     * @param {string} eventName\n     * @param {*} payload\n     * @return {void}\n     */\n    emit(eventName, payload) {\n        this._callEventListeners(eventName, payload);\n    }\n\n    /**\n     * Asynchronously call each of the listeners registered for the event named eventName.\n     *\n     * @param {string} eventName\n     * @param {*} payload\n     * @return {Promise<Array<*>>} - A promise that will be resolved when each of the listeners will be resolved.\n     */\n    emitAsync(eventName, payload) {\n        const defer = new Defer();\n        setImmediate(() => {\n            Promise.all(this._callEventListeners(eventName, payload))\n                .then(defer.resolve)\n                .catch(defer.reject);\n        });\n        return defer.promisify();\n    }\n\n    /**\n     * Add the listener function to the end of the listeners array for the event named eventName.\n     *\n     * @param {string} eventName\n     * @param {function} listener\n     * @return {function} - A function to remove the listener function from the listeners array for the event named eventName.\n     */\n    on(eventName, listener) {\n        assertEventNameParameter(eventName);\n        assertListenerParameter(listener);\n        if (isUndefined(this._events[eventName])) {\n            this._events[eventName] = [];\n        }\n        this._events[eventName].push(listener);\n        return () => {\n            this._events[eventName] = this._events[eventName].filter((eventListener) => eventListener !== listener);\n            // Remove event listeners property to optimize memory usage.\n            if (!this._events[eventName].length) {\n                delete this._events[eventName];\n            }\n        };\n    }\n}\n","import {isFunction, isString, isUndefined} from \"../utils\";\n\n/**\n * Assert \"from\" parameter.\n *\n * @param {*} from\n * @return {void}\n * @throws TypeError\n */\nfunction assertFromParameter(from) {\n    if (!isString(from)) {\n        throw new TypeError('The \"from\" parameter should be a string.');\n    }\n}\n\n/**\n * Assert \"to\" parameter.\n *\n * @param {*} to\n * @return {void}\n * @throws TypeError\n */\nfunction assertToParameter(to) {\n    if (!isString(to)) {\n        throw new TypeError('The \"to\" parameter should be a string.');\n    }\n}\n\n/**\n * Assert \"resolver\" parameter.\n *\n * @param {*} resolver\n * @return {void}\n * @throws TypeError\n */\nfunction assertResolverParameter(resolver) {\n    if (!isFunction(resolver)) {\n        throw new TypeError('The \"resolver\" parameter should be a function.');\n    }\n}\n\n/**\n * Mapper class.\n */\nexport default class Mapper {\n    /**\n     * Mapper constructor.\n     */\n    constructor() {\n        this._resolvers = {};\n        this._assertResolver = this._assertResolver.bind(this);\n        this.registerResolver = this.registerResolver.bind(this);\n        this.hasResolver = this.hasResolver.bind(this);\n        this.removeResolver = this.removeResolver.bind(this);\n        this.map = this.map.bind(this);\n    }\n\n    /**\n     * Assert that the resolver function for from-to mapping exists.\n     *\n     * @param {string} from\n     * @param {string} to\n     * @return {void}\n     * @private\n     */\n    _assertResolver(from, to) {\n        if (isUndefined(this._resolvers[from])) {\n            throw new Error(`Resolver for \"${from}\" not found.`);\n        }\n        if (isUndefined(this._resolvers[from][to])) {\n            throw new Error(`Resolver for \"${to}\" not found.`);\n        }\n    }\n\n    /**\n     * Register the resolver function for from-to mapping.\n     *\n     * @param {string} from\n     * @param {string} to\n     * @param {function} resolver\n     * @return {Mapper}\n     */\n    registerResolver(from, to, resolver) {\n        assertFromParameter(from);\n        assertToParameter(to);\n        assertResolverParameter(resolver);\n        if (isUndefined(this._resolvers[from])) {\n            this._resolvers[from] = {};\n        }\n        this._resolvers[from][to] = resolver;\n        return this;\n    }\n\n    /**\n     * Determine that the resolver function for from-to mapping is registered.\n     *\n     * @param {string} from\n     * @param {string} to\n     * @return {boolean}\n     */\n    hasResolver(from, to) {\n        assertFromParameter(from);\n        assertToParameter(to);\n        try {\n            this._assertResolver(from, to);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Remove the resolver function for from-to mapping.\n     *\n     * @param {string} from\n     * @param {string} to\n     * @return {Mapper}\n     */\n    removeResolver(from, to) {\n        assertFromParameter(from);\n        assertToParameter(to);\n        if (this.hasResolver(from, to)) {\n            delete this._resolvers[from][to];\n        }\n        return this;\n    }\n\n    /**\n     * Map value by using from-to resolver function.\n     *\n     * @param {*} value\n     * @param {string} from\n     * @param {string} to\n     * @return {*}\n     */\n    map(value, from, to) {\n        assertFromParameter(from);\n        assertToParameter(to);\n        this._assertResolver(from, to);\n        const resolver = this._resolvers[from][to];\n        return resolver(value);\n    }\n}\n"],"names":["Defer","_promise","Promise","resolve","reject","promisify","bind","DEFAULT_TIME_INTERVAL","timeout","timeInterval","defer","setTimeout","isArray","value","Array","isBoolean","Boolean","isUndefined","isDefined","isFunction","isNull","isNumber","Number","isNumeric","isNaN","parseFloat","isFinite","isObject","isString","String","cloneUndefined","undefined","cloneNull","cloneBoolean","cloneNumber","cloneString","cloneArray","map","item","clone","cloneMap","Map","from","cloneDate","Date","valueOf","cloneRegExp","pattern","source","flags","global","ignoreCase","multiline","RegExp","cloneObject","nodeType","cloneNode","prototype","Object","keys","reduce","clonedObject","key","property","Error","cloneFunction","clonedFunction","apply","arguments","forEach","optional","callback","defaultValue","error","assertCallbackParameter","TypeError","waitUntil","intervalId","setInterval","result","clearInterval","assertIdentifierParameter","identifier","assertTypeParameter","type","assertDependenciesParameter","dependencies","dependency","assertSingletonParameter","singleton","assertFactoryParameter","factory","assertInstanceParameter","instance","DependencyContainer","_bindings","_createInstance","_resolveDependencies","registerBinding","registerInstance","removeBinding","has","get","binding","length","innerDependency","hasOwnProperty","call","assertEventNameParameter","eventName","assertListenerParameter","listener","EventEmitter","_events","_callEventListeners","emit","emitAsync","on","payload","listeners","setImmediate","all","then","catch","push","filter","eventListener","assertFromParameter","assertToParameter","to","assertResolverParameter","resolver","Mapper","_resolvers","_assertResolver","registerResolver","hasResolver","removeResolver"],"mappings":"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"}